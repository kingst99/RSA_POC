<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>RSA測試工具使用說明如下：

一、概念介紹

１．加簽：使用自己的電子簽章可保護自己的訊息在傳送過程不會被別人竄改。

２．加密：傳送訊息者(以下簡稱甲方)再利用接收者（以下簡稱乙方）先前送的公鑰來加密這封信的內容，
只有乙方的私鑰能解密，因此除了對方以外不會被第三者看到內容。

　假設兩方通信往返時就是輪流扮演介面的甲乙方，
因此本測試所模擬情境過程只需設計完整的一次傳接就能驗證此技術。



二、模擬情境

　為達到概念目的，我們用RSA非對稱加密技術來實作模擬情境時所需功能，
一開始雙方先互相送給對方的自己的公鑰（註１），並保護好自己的私鑰，
這部分動作是雙方用來收信的標準流程。

　當乙方收到信時，因為密文是甲方用乙方的公鑰加密的，所以乙方用自己的私鑰就解密看到內容了，若信被中途攔截，因為攔截者沒有私鑰也無法得知內容。

　若甲方寄信同時附上那一封信的電子簽章，乙方就可以利用甲方先前送給他的公鑰，對信息內容(已解密後的)作驗證。
若驗證為真，代表該信件內容沒有被變造或竄改過。

　以上情境這就是本程式要實作的雙向加密功能(本功能不包含公正第三方對公鑰提供者之身分認證的實作亦即SSL憑證原理)。



三、測試工具使用說明：

測試SOP共兩個測試項目，

第一項目為基本測試，全部有７個步驟，１～５屬於傳送方步驟，６～７為接收方步驟。
第二項目為驗證測試，全部有６個步驟，１～３屬於簽章驗證步驟，４～５為解密驗證步驟。


Ａ．基本測試

步驟1.請先在＂產生金鑰＂頁籤利用程式產生甲乙兩方的公私金鑰，程式會在適當情境使用，也就是(註1)所說的交換公鑰動作。

步驟2.備妥雙方金鑰後請切換至＂傳送方＂頁籤，模擬甲方在＂文件＂欄位填寫一段要寄給乙方的訊息或是一把(註２)對稱加密的金鑰。

步驟3.寫完訊息若甲方認為需要為這訊息內容產生一個獨一無二的電子簽章，這個動作稱為＂加簽＂，請按下＂使用我方(甲方)私鑰根據文件產生電子簽章＂按鈕。

步驟4.加簽之後甲方認為這封信內容只能被乙方讀取，因此再使用手上的乙方公鑰來加密，請按下＂使用接收方(乙方)公鑰加密要傳送的文件＂按鈕將內容欄位的訊息加密。

步驟5.完成１～４步驟後請按下＂傳送＂，代表將密文和電子簽章伊請寄給乙方。

步驟7.完成傳送後請切換至＂接收方＂頁籤，模擬乙方在收到的密文後使用私鑰解密，請按下＂使用我方(乙方)私鑰解密文件＂按鈕將＂加密內容＂欄位的訊息解密。

步驟6.乙方並對解密後的內容進行簽章驗證，請按下＂使用傳送方(甲方)公鑰驗證電子簽章＂按鈕。


Ｂ．驗證測試

步驟1.完成基本測試後再將傳送方原來的＂加密內容＂作修改，拷貝至＂接收方＂頁籤的＂原始內容＂欄位。

步驟2.請按下＂使用傳送方(甲方)公鑰驗證電子簽章＂按鈕，結果應顯示驗證失敗，因為內容與電子簽章不符。

步驟3.請至＂傳送方＂頁籤，執行基本測試－步驟3，重新產生電子簽章後拷貝至接收方的＂電子簽章＂欄位，再執行一次步驟２，應顯示通過驗證，表示內容與電子簽章吻合。

步驟4.請至＂傳送方＂頁籤，執行基本測試－步驟4，以同樣的文件內容重複至少３次，同時觀察加密後顯示於＂加密內容＂欄位的值，結果應每次密文皆不同。

步驟5.現在請將＂傳送方＂頁籤＂加密內容＂欄位的值，拷貝至＂接收方＂頁籤的＂加密內容＂欄位，再執行一次基本測試－步驟7來解密，結果每次密文解出內容皆同原文，顯示RSA演算法的加密特性。



　　　　　　　　　　　　　　　　　　　　　　　This RSA POC Powered by kingst99@gmail.com from Nelson.Yuan</value>
  </data>
</root>